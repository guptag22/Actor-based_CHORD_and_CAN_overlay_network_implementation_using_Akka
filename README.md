# Homework 3 : 

### Description: Design and implement an Actor-based computational model for the Chord overlay network algorithm

## Team Members (Group 11)

Garima Gupta (ggupta22)

Avani Mande (amande6)

Samujjwaal Dey (sdey9)

## Overview
As part of this project a cloud simulation is implemented based on the Chord overlay network algorithm using the Akka typed actor model. 

The simulation has three main components. The user system which generates user actors and sends read or write requests to the http server. The http server is another component which forwards these requests to the chord system. 



## Chord Algorithm

The Chord algorithm uses convergent hashing which when given a key returns a value. It is a peer to peer distributed hash table. 
Solves problem of locating a data item in a collection of distributed nodes, considering frequent node arrivals and departures
We implement a simpler version where fault tolerance is not taken into consideration.



## Akka HTTP

We use the [Akka HTTP](https://doc.akka.io/docs/akka-http/current/introduction.html) functionality which builds up on Akka actors and Akka streams to provide a complete client and server side functionality. We use DSL routes to define two requests that the server services. GET and POST.
The GET request is used to read a value given that the user provides a key. The GET request then sends a ask to the chord system to retrieve the given value. The POST request takes two arguments, key and value which are to be written to a node and sends a tell message to the chord system. The server responds to the user with the corresponding value for the read request key. For a write request, the server responds with a simple message saying that the operation is done.



## Application Design

### Some Important Files

- The file `MessageTypes` lists all the types of messages that can be processed by the chord node actor,user actor, chord actor system and for data request.
- `ChordNode` is the class for modelling a single node in the Chord ring. Each node is an akka actor and can process protocol messages of the type `NodeCommand` to alter it’s state or behavior.
  - The state of the `ChordNode` actor stores node references and node hash values of its successor & predecessor nodes, the current node’s fingertable and the data being stored on the node.
  - The messages are sent to the actor using the tell/ask actor interaction patterns to perform operation on the chord node like joining the chord network, updating node finger table and display finger table status. 
- `Finger` case class defines each finger entry in a node’s finger table. A case class is used as the compiler provides in-built getter, setter and other boilerplate code. Each finger table entry stores the hash value of the start index, node reference and node hash value of the successor node w.r.t the start index.
- `ChordHttpServer` defines an actor that will operate as the Akka HTTP server and the Chord node server. It can process protocol messages of type `ChordSystemCommand`. The server spawns actors for each chord node and adds it to a hashmap storing node IDs and node references. A node is selected from this hashmap in random and added to the chord system using the ask actor interaction pattern.
- `User` is the class for modelling a user in the overlay network. Each user is an akka actor and can accept protocol messages of type `DataRequest`
- `UserSystem` defines the actor responsible to create multiple users for the overlay system and simulate their operations.
- `ChordUtils` defines the `md5()` hashing function used to generate the hash values for chord node IDs and key positions in the chord ring.
- `Utils` defines the methods for generating random requests to the overlay network. The function `randomlySelectRequestType()` determines whether the next request generated by the user will be a data read or data write request. While the function `randomlySelectDataIndex()` selects random index of a data from the file to perform the read/write request.
- `Main` is the driver class for the simulation. It is responsible for instantiation of the `ChordHttpServer` and `UserSystem` actor systems.



## Data Used

The data that we use here for this simulation is available in resourses/listfile.txt and contains comma-separated-values of a title song and its release year.
The user uses this data to query for a song year given a song title. The link from which the dataset is obtained is given here. http://millionsongdataset.com/pages/getting-dataset/

A small subset of the dataset is chosen. The data is preprocessed in python to retrieve just two characteristics namely the song name and song year. 



## Instructions to Execute

1. Clone this repository from Bitcucket
2. Run `sbt clean compile test` to compile the project and run test cases
3. Import as sbt project in IntelliJ IDE
4. Run the `Main` scala class file to execute the simulation



### References

GitHub repositories: 

- [Link 1](https://github.com/pramo31/ChordSimulator)
- [Link 2](https://github.com/Swati32/Chord-Implementation-in-scala)
- [Link 3](https://github.com/softinio/pat)

Documentation:

[Akka Typed Actor Model](https://doc.akka.io/docs/akka/current/typed/index.html)

[Akka HTTP](https://doc.akka.io/docs/akka-http/current/introduction.html)

[Chord Algorithm](https://pdos.csail.mit.edu/papers/chord:sigcomm01/chord_sigcomm.pdf)



